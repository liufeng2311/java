*线程池的拒绝策略(定义在ThreadPoolExecutor中)，实现RejectedExecutionHandler接口
策略如下：AbortPolicy                 抛异常
          DiscardPolicy               不作任何处理
		  DiscardOldestPolicy         如果线程池没有关闭的话，抛弃队列里末尾的任务、并将这个存入队列末尾
		  CallerRunsPolicy            如何线程池没有关闭的话，由调用线程处理该任务
		  

LinkedBlockingQueue  阻塞队列

ReentrantLock        锁
线程池的几个状态：
RUNNING     可创建线程，可以往队列里添加任务
SHUTDOWN    可创建线程，不可以往队列里添加任务

execute(Runnable command)方法解读
1.如果参数为空，则抛出空指针异常
2.workerCountOf(c)获取当前线程数，如果此时线程数 < corePoolSize，尝试创建新线程，创建成功，返回，否则执行下一步     (当前线程池中线程数小于核心线程池大小，则创建线程,)
3.如果当前线程数以达到核心线程池大小，则尝试将任务放到队列里，放入队列里时线程池的状态必须是RUNNING，放入队列成功做进一步判断
    加入队列前后要保证线程池状态都为RUNNING，如果放入队列后线程成状态不是RUNNING，则可能放入队列前状态已经大于RUNNING，我们需要移除刚刚放入队列的任务，并执行拒绝策略(其实线程池状态可能是加入后才变化的，这里只是一种预防策略)
	如果加入后状态依旧为RUNNING，但可能在加入队列前线程都已经关闭，判断此时线程数是否为零,是的话就创建一个不带任务的空线程去读取队列里的任务
4.如果队列已满，尝试开启新的线程执行该任务(此时判断的是是否达到了线程池最大大小)，没有达到则创建新线程，否则执行拒绝策略



addWorker()方法解读(主要分为两步)
1.判断是否可以创建线程，不可以的话直接返回false，可以的话，使线程池中线程计数+1，同时要保证加一之后线程的状态依旧满足创建线程的条件(此处采用死循环方式时条件满足)
   先判断是否满足创建线程的条件，条件如下：
   当线程池状态为STOP、TIDYING、TERMINATED，不允许创建线程 
   当线程池状态为SHUTDOWN时，队列中的任务不为空时，可创建线程(此时不允许往队列中添加新的任务)
   当线程池线程数大于最大线程数不予许创建线程
   当线程池大于核心线程数或者最大线程数(两者通过传参确定)，正常情况都是用核心线程数、只有队列满了之后才才判断最大线程数，
   
   满足创建条件后，先将线程池中的线程计数+1
2.创建线程并启动线程
	Worker是我们创建的线程，并将提交的任务作为该线程的第一个任务(该线程run()方法里死循环读取队列中的任务)
	将Worker 添加到set集合中，仅仅当拥有mainLock锁时才能访问该集合，并用largestPoolSize记录该集合达到的最大值，即记录最多有多少个线程同时运行，该步骤需要加锁，hashset非线程安全
	启动线程，启动成功就添加成功，启动失败进行回滚，即线程数-1，删除set中的该work
runWorker(Worker w)方法解读(线程启动后执行对应的run方法,run方法执行的就是该方法)(主要任务四执行当前任务并循环读取队列中的任务，执行他们的run方法，其实不没有启动新的线程)



interrupted()是个Thread的static方法，用来恢复中断状态，内部调用isInterrupted(true)，    设置中断状态为true
isInterrupted()方法调用isInterrupted(false)，与上面相反                                 设置中断状态为false
interrupt()方法在一个线程中调用另一个线程的interrupt()方法，即会向那个线程发出信号——线程中断状态已被设置。至于那个线程何去何从，由具体的代码实现决定。







问题：worker    state为嘛设置成-1


worker执行时为嘛先放锁












	

